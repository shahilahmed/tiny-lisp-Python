from Core.Utils import *level = 0def transpile_arith(exp = []):	global level	symbol = exp[0]	result = ""	result = result + "{}".format(transpile_exp(exp[1]))	for arg in exp[2:]:		if symbol == "add":			result = result + " + {}".format(transpile_exp(arg))		elif symbol == "sub":			result = result + " - {}".format(transpile_exp(arg))		elif symbol == "mul":			result = result + " * {}".format(transpile_exp(arg))		elif symbol == "div":			result = result + " / {}".format(transpile_exp(arg))		elif symbol == "mod":			result = result + " % {}".format(transpile_exp(arg))	result = "({})".format(result)	return resultdef transpile_cond(exp = []):	global level	symbol = exp[0]	result = ""	result = result + "{}".format(transpile_exp(exp[1]))	for arg in exp[2:]:		if symbol == "eq":			result = result + " == {}".format(transpile_exp(arg))		elif symbol == "ne":			result = result + " != {}".format(transpile_exp(arg))		elif symbol == "lt":			result = result + " <  {}".format(transpile_exp(arg))		elif symbol == "le":			result = result + " <= {}".format(transpile_exp(arg))		elif symbol == "gt":			result = result + " >  {}".format(transpile_exp(arg))		elif symbol == "ge":			result = result + " >= {}".format(transpile_exp(arg))	result = "({})".format(result)	return resultdef transpile_bitwise(exp = []):	global level	symbol = exp[0]	result = ""	result = result + "{}".format(transpile_exp(exp[1]))	for arg in exp[2:]:		if symbol == "and":			result = result + "  & {}".format(transpile_exp(arg))		elif symbol == "or":			result = result + "  | {}".format(transpile_exp(arg))		elif symbol == "not":			result = result + "  |  (~{})".format(transpile_exp(arg))		elif symbol == "xor":			result = result + " ^ {}".format(transpile_exp(arg))		elif symbol == "shl":			result = result + " <<  {}".format(transpile_exp(arg))		elif symbol == "shr":			result = result + " >> {}".format(transpile_exp(arg))	result = "({})".format(result)	return resultdef transpile_specials(exp = []):	global level	symbol = exp[0]	result = None	if symbol == "lambda":		result = "lambda {} : {}".format(",".join(exp[1]),transpile_exp(exp[2]))	elif symbol == "defun":		level = level + 4		args = ",".join(exp[1][1:])		result = transpile_exp(["lambda",exp[1][1:],exp[2]])		result = "{}({})".format(result,args)		result = ' ' * level + "return " + result		result = "def {}({}):\n{}".format(exp[1][0],args,result)		level = level - 4	elif symbol == "define":		result = "{} = {}".format(exp[1],transpile_exp(exp[2]))	elif symbol == "set":		result = "{} = {}".format(exp[1],transpile_exp(exp[2]))	elif symbol == "if":		result = "{} if {} else {}".format(transpile_exp(exp[2]),transpile_exp(exp[1]),transpile_exp(exp[3]))	elif symbol == "cond":		data = []		for (p,e) in exp[1:]:			data.append(transpile_exp(p))			data.append(transpile_exp(e))		temp = []		loc = 0		while loc <= len(data) - 2:			temp.append("{} if {} else ".format(data[loc + 1],data[loc]))			loc = loc + 2		temp[-1] = temp[-1] + " None" 		result = " ".join(temp)	elif symbol == "block":		pass		'''		data = []		level = level + 4		for arg in exp[1:]:			data.append(' ' * level + transpile_exp(arg) + '\n')		result = "".join(data)		level = level - 4		'''	if symbol not in ["define","set","defun","block"]:		result = "({})".format(result)	return result		def	transpile_exp(exp = []):	global level	result = None	if isinstance(exp,list):		if len(exp) == 0:			return ""		symbol = exp[0]		if symbol in ["add","sub","mul","div","mod"]:			result = transpile_arith(exp)		elif symbol in ["eq","ne","lt","le","gt","ge"]:			result = transpile_cond(exp)		elif symbol in ["and","or","not","xor","shl","shr"]:			result = transpile_bitwise(exp)		elif symbol in ["lambda","if","defun","define","set","cond"]:			result = transpile_specials(exp)		else:			proc = transpile_exp(symbol)			if proc in [True,False]:				return proc			args = [str(transpile_exp(arg)) for arg in exp[1:]]			result = "{}({})".format(proc,",".join(args))	else:		result = exp	return result	def transpile(tree = []):	global level	data = []	for exp in tree:		data.append(transpile_exp(exp))	result = "\n\n".join(data)	##print(result)	return result			